<?php

namespace Drupal\datastore\DataDictionary\DateFormat;

use Drupal\datastore\DataDictionary\GrammarInterface;
use Drupal\datastore\DataDictionary\ParserInterface;
use Drupal\datastore\DataDictionary\UnknownTokenException;

/**
 * Date format parser.
 */
class Parser implements ParserInterface {

  /**
   * Creates a date format parser.
   *
   * @param \Drupal\datastore\DataDictionary\GrammarInterface $grammar
   *   Grammar for date format being parsed.
   */
  public function __construct(GrammarInterface $grammar) {
    $this->grammar = $grammar;
  }

  /**
   * Break up supplied date format string into lexemes.
   *
   * @param string $input_format
   *   Date format string to lex.
   *
   * @return \Drupal\datastore\DataDictionary\FrictionlessDateFormatConverter\TokenInterface[]
   *   Token list.
   */
  protected function lex(string $input_format): array {
    // Initialize our AST reference and local DB output format string.
    $grammar_ptr = &$this->grammar;
    $syntax = [];
    $literal = '';

    // Traverse the AST:
    foreach (str_split($input_format) as $char) {
      $literal .= $char;
      // If the current character doesn't exist in this level of the AST, we
      // have no path to tokenizing it; therefore, we want to go back to the top
      // level of the AST and write the current character to the output format.
      if (!isset($grammar_ptr[$char])) {
        // If no valid AST character was found mid-token, the given frictionless
        // format is invalid, and an exception should be thrown.
        if (strlen($literal) > 1) {
          throw new UnknownTokenException(sprintf('Invalid frictionless format provided; unknown token "%s".', $token));
        }
        $syntax[] = new LiteralToken($literal);
        $grammar_ptr = &$this->grammar;
        $literal = '';
      }
      // Otherwise, we have a path forward...
      else {
        // If the current character is not an end node in the AST, continue down
        // the AST path.
        if (is_array($grammar_ptr[$char])) {
          $grammar_ptr = &$grammar_ptr[$char];
        }
        // If the current character is an end node, write the content of the end
        // node to the output format, and go back to the top level of the AST.
        else {
          $syntax[] = new DirectiveToken($literal);
          $grammar_ptr = &$this->grammar;
          $literal = '';
        }
      }
    }

    return $syntax;
  }

  /**
   * Generate an Abstract Syntax Tree (AST) from the given date format.
   *
   * @param string $input
   *   Frictionless date format.
   *
   * @return array
   *   Generated AST.
   */
  public function parse(string $input): array {
    // Break input format up into list of lexemes.
    $syntax = $this->lex($input);

    // Since the language we're working with is linear and does not contain
    // complex expressions, a multi-level AST doesn't need to be generated, the
    // tokens generated by the lexer can be returned as a single level "AST".
    return $syntax;
  }
}
