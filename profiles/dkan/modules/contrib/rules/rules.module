<?php

/**
 * @file Rules engine module
 */

/**
 * Implements hook_init().
 */
function rules_init() {
  module_load_include('inc', 'rules', 'modules/events');
  rules_invoke_event('init');
}

/**
 * Returns an instance of the rules UI controller, which eases re-using the Rules UI.
 *
 * See the rules_admin.module for example usage.
 *
 * @return RulesUIController
 */
function rules_ui() {
  $static = drupal_static(__FUNCTION__);
  if (!isset($static)) {
    $static = new RulesUIController();
  }
  return $static;
}

/**
 * Returns a new rules action.
 *
 * @param $name
 *   The action's name.
 * @param $settings
 *   The action's settings array.
 * @return RulesAction
 */
function rules_action($name, $settings = array()) {
  return rules_plugin_factory('action', $name, $settings);
}

/**
 * Returns a new rules condition.
 *
 * @param $name
 *   The condition's name.
 * @param $settings
 *   The condition's settings array.
 * @return RulesCondition
 */
function rules_condition($name, $settings = array()) {
  return rules_plugin_factory('condition', $name, $settings);
}

/**
 * Creates a new rule.
 *
 * @param $variables
 *   The array of variables to setup in the evaluation state, making them
 *   available for the configuraion elements. Values for the variables need to
 *   be passed as argument when the rule is executed. Only Rule instances with
 *   no variables can be embedded in other configurations, e.g. rule sets.
 *   The array has to be keyed by variable name and contain a sub-array for each
 *   variable that has the same structure as the arrays used for describing
 *   parameters of an action, see hook_rules_action_info(). However, in addition
 *   to that the following keys are supported:
 *    - parameter: (optional) If set to FALSE, no parameter for the variable
 *      is created - thus no argument needs to be passed to the rule for the
 *      variable upon execution. As a consequence no value will be set
 *      initially, but the "Set data value" action may be used to do so. This is
 *      in particular useful for defining variables which can be provided to the
 *      caller (see $provides argument) but need not be passed in as parameter.
 * @param $provides
 *   The names of variables which should be provided to the caller. Only
 *   variables contained in $variables may be specified.
 * @return Rule
 */
function rule($variables = NULL, $provides = array()) {
  return rules_plugin_factory('rule', $variables, $provides);
}

/**
 * Creates a new reaction rule.
 *
 * @return RulesReactionRule
 */
function rules_reaction_rule() {
  return rules_plugin_factory('reaction rule');
}

/**
 * Creates a logical OR condition container.
 *
 * @param $variables
 *   An optional array as for rule().
 * @return RulesOr
 */
function rules_or($variables = NULL) {
  return rules_plugin_factory('or', $variables);
}

/**
 * Creates a logical AND condition container.
 *
 * @param $variables
 *   An optional array as for rule().
 * @return RulesAnd
 */
function rules_and($variables = NULL) {
  return rules_plugin_factory('and', $variables);
}

/**
 * Creates a loop.
 *
 * @param $settings
 *   The loop settings, containing
 *     'list:select': The data selector for the list to loop over.
 *     'item:var': Optionally a name for the list item variable.
 *     'item:label': Optionally a lebel for the list item variable.
 * @param $variables
 *   An optional array as for rule().
 * @return RulesLoop
 */
function rules_loop($settings = array(), $variables = NULL) {
  return rules_plugin_factory('loop', $settings, $variables);
}

/**
 * Creates a rule set.
 *
 * @param $variables
 *   An array as for rule().
 * @param $provides
 *   The names of variables which should be provided to the caller. See rule().
 * @return RulesRuleSet
 */
function rules_rule_set($variables = array(), $provides = array()) {
  return rules_plugin_factory('rule set', $variables, $provides);
}

/**
 * Creates an action set.
 *
 * @param $variables
 *   An array as for rule().
 * @param $provides
 *   The names of variables which should be provided to the caller. See rule().
 * @return RulesActionSet
 */
function rules_action_set($variables = array(), $provides = array()) {
  return rules_plugin_factory('action set', $variables, $provides);
}

/**
 * Log a message to the rules logger.
 *
 * @param $msg
 *   The message to log.
 * @param $args
 *   An array of placeholder arguments as used by t().
 * @param $priority
 *   A priority as defined by the RulesLog class.
 * @param RulesPlugin $element
 *  (optional) The RulesElement causing the log entry.
 * @param boolean $scope
 *  (optional) This may be used to denote the beginning (TRUE) or the end
 *  (FALSE) of a new execution scope.
 */
function rules_log($msg, $args = array(), $priority = RulesLog::INFO, RulesPlugin $element = NULL, $scope = NULL) {
  static $logger, $settings;

  // Statically cache the variable settings as this is called very often.
  if (!isset($settings)) {
    $settings['rules_log_errors'] = variable_get('rules_log_errors', RulesLog::WARN);
    $settings['rules_debug_log'] = variable_get('rules_debug_log', FALSE);
    $settings['rules_debug'] = variable_get('rules_debug', FALSE);
  }

  if ($priority >= $settings['rules_log_errors']) {
    $link = NULL;
    if (isset($element) && isset($element->root()->name)) {
      $link = l(t('edit configuration'), RulesPluginUI::path($element->root()->name, 'edit', $element));
    }
    watchdog('rules', $msg, $args, $priority == RulesLog::WARN ? WATCHDOG_WARNING : WATCHDOG_ERROR, $link);
  }
  // Do nothing in case debugging is totally disabled.
  if (!$settings['rules_debug_log'] && !$settings['rules_debug']) {
    return;
  }
  if (!isset($logger)) {
    $logger = RulesLog::logger();
  }
  $path = isset($element) && isset($element->root()->name) ? RulesPluginUI::path($element->root()->name, 'edit', $element) : NULL;
  $logger->log($msg, $args, $priority, $scope, $path);
}

/**
 * Fetches module definitions for the given hook name.
 *
 * Used for collecting events, rules, actions and condtions from other modules.
 *
 * @param $hook
 *   The hook of the definitions to get from invoking hook_rules_{$hook}.
 */
function rules_fetch_data($hook) {
  $data = &drupal_static(__FUNCTION__, array());

  if (!isset($data[$hook])) {
    foreach (module_implements('rules_' . $hook) as $module) {
      $result = call_user_func($module . '_rules_' . $hook);
      if (isset($result) && is_array($result)) {
        foreach ($result as $name => $item) {
          $item += array('module' => $module);
          $data[$hook][$name] = $item;
        }
      }
    }
    drupal_alter('rules_'. $hook, $data[$hook]);
  }
  return $data[$hook];
}

/**
 * Gets a rules cache entry.
 */
function &rules_get_cache($cid = 'data') {
  // Make use of the fast, advanced drupal static pattern.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['cache'] = &drupal_static(__FUNCTION__, array());
  }
  $cache = &$drupal_static_fast['cache'];

  if (!isset($cache[$cid])) {
    // The main 'data' cache includes translated strings, so each language is
    // cached separately.
    $cid_suffix = $cid == 'data' ? ':' . $GLOBALS['language']->language : '';

    if ($get = cache_get($cid . $cid_suffix, 'cache_rules')) {
      $cache[$cid] = $get->data;
    }
    elseif ($cid === 'data') {
      // There is no 'data' cache so we need to rebuild it. Make sure subsequent
      // cache gets of the main 'data' cache during rebuild get the interim
      // cache by passing in the reference of the static cache variable.
      _rules_rebuild_cache($cache['data']);
    }
    elseif (strpos($cid, 'comp_') === 0) {
      $cache[$cid] = FALSE;
      _rules_rebuild_component_cache();
      return $cache[$cid];
    }
    elseif (strpos($cid, 'event_') === 0) {
      $cache[$cid] = FALSE;
      RulesEventSet::rebuildEventCache();
      return $cache[$cid];
    }
    else {
      $cache[$cid] = FALSE;
    }
  }
  return $cache[$cid];
}

/**
 * Rebuilds the rules cache.
 *
 * This rebuilds the rules 'data' cache and invokes rebuildCache() methods on
 * all plugin classes, which allows plugins to add their own data to the cache.
 * The cache is rebuilt in the order the plugins are defined.
 *
 * Note that building the action/condition info cache triggers loading of all
 * components, thus depends on entity-loading and so syncing entities in code
 * to the database.
 *
 * @see rules_rules_plugin_info()
 * @see entity_defaults_rebuild()
 */
function _rules_rebuild_cache(&$cache) {
  foreach(array('data_info', 'plugin_info') as $hook) {
    $cache[$hook] = rules_fetch_data($hook);
  }
  foreach ($cache['plugin_info'] as $name => &$info) {
    // Let the items add something to the cache.
    $item = new $info['class']();
    $item->rebuildCache($info, $cache);
  }
  $cid_suffix = ':' . $GLOBALS['language']->language;
  cache_set('data' . $cid_suffix, $cache, 'cache_rules');
}

/**
 * Cache components to allow efficient usage via rules_invoke_component().
 *
 * @see rules_invoke_component()
 * @see rules_get_cache()
 */
function _rules_rebuild_component_cache() {
  $components = rules_get_components();

  foreach ($components as $id => $component) {
    // If a component is marked as dirty, check if this still applies.
    if ($component->dirty) {
      rules_config_update_dirty_flag($component);
    }
    if (!$component->dirty) {
      // Clone the component to avoid modules getting the to be cached
      // version from the static loading cache.
      $component = clone $component;
      $component->optimize();
      // Allow modules to alter the cached component.
      drupal_alter('rules_component', $component->plugin, $component);
      rules_set_cache('comp_' . $component->name, $component);
    }
  }
}

/**
 * Sets a rules cache item.
 *
 * In addition to calling cache_set(), this function makes sure the cache item
 * is immediately available via rules_get_cache() by keeping all cache items
 * in memory. That way we can garantuee rules_get_cache() is able to retrieve
 * any cache item, even if all cache gets fail.
 *
 * @see rules_get_cache()
 */
function rules_set_cache($cid, $data) {
  $cache = &drupal_static('rules_get_cache', array());
  $cache[$cid] = $data;
  cache_set($cid, $data, 'cache_rules');
}

/**
 * Implements hook_flush_caches().
 */
function rules_flush_caches() {
  variable_del('rules_empty_sets');
  return array('cache_rules');
}

/**
 * Clears the rule set cache
 */
function rules_clear_cache() {
  cache_clear_all('*', 'cache_rules', TRUE);
  variable_del('rules_empty_sets');
  drupal_static_reset('rules_get_cache');
  drupal_static_reset('rules_fetch_data');
  drupal_static_reset('rules_config_update_dirty_flag');
  entity_get_controller('rules_config')->resetCache();
}

/**
 * Imports the given export and returns the imported configuration.
 *
 * @param $export
 *   A serialized string in JSON format as produced by the RulesPlugin::export()
 *   method, or the PHP export as usual PHP array.
 * @return RulesPlugin
 */
function rules_import($export, &$error_msg = '') {
  return entity_get_controller('rules_config')->import($export, $error_msg);
}


/**
 * Wraps the given data.
 *
 * @param $data
 *   If available, the actual data, else NULL.
 * @param $info
 *   An array of info about this data.
 * @param $force
 *   Usually data is only wrapped if really needed. If set to TRUE, wrapping the
 *   data is forced, so primitive data types are also wrapped.
 * @return EntityMetadataWrapper
 *   An EntityMetadataWrapper or the unwrapped data.
 *
 * @see hook_rules_data_info()
 */
function &rules_wrap_data($data = NULL, $info, $force = FALSE) {
  // If the data is already wrapped, use the existing wrapper.
  if ($data instanceof EntityMetadataWrapper) {
    return $data;
  }
  $cache = rules_get_cache();
  // Define the keys to be passed through to the metadata wrapper.
  $wrapper_keys = array_flip(array('property info', 'property defaults'));
  if (isset($cache['data_info'][$info['type']])) {
    $info += array_intersect_key($cache['data_info'][$info['type']], $wrapper_keys);
  }
  // If a list is given, also add in the info of the item type.
  $list_item_type = entity_property_list_extract_type($info['type']);
  if ($list_item_type && isset($cache['data_info'][$list_item_type])) {
    $info += array_intersect_key($cache['data_info'][$list_item_type], $wrapper_keys);
  }
  // By default we do not wrap the data, except for completely unknown types.
  if (!empty($cache['data_info'][$info['type']]['wrap']) || $list_item_type || $force || empty($cache['data_info'][$info['type']])) {
    unset($info['handler']);
    // Allow data types to define custom wrapper classes.
    if (!empty($cache['data_info'][$info['type']]['wrapper class'])) {
      $class = $cache['data_info'][$info['type']]['wrapper class'];
      $wrapper = new $class($info['type'], $data, $info);
    }
    else {
      $wrapper = entity_metadata_wrapper($info['type'], $data, $info);
    }
    return $wrapper;
  }
  return $data;
}

/**
 * Unwraps the given data, if it's wrapped.
 *
 * @param $data
 *   An array of wrapped data.
 * @param $info
 *   Optionally an array of info about how to unwrap the data. Keyed as $data.
 * @return
 *   An array containing unwrapped or passed through data.
 */
function rules_unwrap_data(array $data, $info = array()) {
  $cache = rules_get_cache();
  foreach ($data as $key => $entry) {
    // If it's a wrapper, unwrap unless specified otherwise.
    if ($entry instanceof EntityMetadataWrapper) {
      if (!isset($info[$key]['allow null'])) {
        $info[$key]['allow null'] = FALSE;
      }
      if (!isset($info[$key]['wrapped'])) {
        // By default, do not unwrap special data types that are always wrapped.
        $info[$key]['wrapped'] = (isset($info[$key]['type']) && is_string($info[$key]['type']) && !empty($cache['data_info'][$info[$key]['type']]['is wrapped']));
      }
      // Activate the decode option by default if 'sanitize' is not enabled, so
      // any text is either sanitized or decoded.
      // @see EntityMetadataWrapper::value()
      $options = $info[$key] + array('decode' => empty($info[$key]['sanitize']));

      try {
        if (!($info[$key]['allow null'] && $info[$key]['wrapped'])) {
          $value = $entry->value($options);

          if (!$info[$key]['wrapped']) {
            $data[$key] = $value;
          }
          if (!$info[$key]['allow null'] && !isset($value)) {
            throw new RulesEvaluationException('The variable or parameter %name is empty.', array('%name' => $key));
          }
        }
      }
      catch (EntityMetadataWrapperException $e) {
        throw new RulesEvaluationException('Unable to get the data value for the variable or parameter %name. Error: !error', array('%name' => $key, '!error' => $e->getMessage()));
      }
    }
  }
  return $data;
}

/**
 * Creates a new instance of a the given rules plugin.
 *
 * @return RulesPlugin
 */
function rules_plugin_factory($plugin_name, $arg1 = NULL, $arg2 = NULL) {
  $cache = rules_get_cache();
  if (isset($cache['plugin_info'][$plugin_name]['class'])) {
    return new $cache['plugin_info'][$plugin_name]['class']($arg1, $arg2);
  }
}

/**
 * Implementation of hook_rules_plugin_info().
 *
 * Note that the cache is rebuilt in the order of the plugins. Therefore the
 * condition and action plugins must be at the top, so that any components
 * re-building their cache can create configurations including properly setup-ed
 * actions and conditions.
 */
function rules_rules_plugin_info() {
  return array(
    'condition' => array(
      'class' => 'RulesCondition',
      'embeddable' => 'RulesConditionContainer',
      'extenders' => array (
        'RulesPluginImplInterface' => array(
          'class' => 'RulesAbstractPluginDefaults',
        ),
        'RulesPluginFeaturesIntegrationInterace' => array(
          'methods' => array(
            'features_export' => 'rules_features_abstract_default_features_export',
          ),
        ),
        'RulesPluginUIInterface' => array(
          'class' => 'RulesAbstractPluginUI',
        ),
      ),
    ),
    'action' => array(
      'class' => 'RulesAction',
      'embeddable' => 'RulesActionContainer',
      'extenders' => array (
        'RulesPluginImplInterface' => array(
          'class' => 'RulesAbstractPluginDefaults',
        ),
        'RulesPluginFeaturesIntegrationInterace' => array(
          'methods' => array(
            'features_export' => 'rules_features_abstract_default_features_export',
          ),
        ),
        'RulesPluginUIInterface' => array(
          'class' => 'RulesAbstractPluginUI',
        ),
      ),
    ),
    'or' => array(
      'label' => t('Condition set (OR)'),
      'class' => 'RulesOr',
      'embeddable' => 'RulesConditionContainer',
      'component' => TRUE,
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesConditionContainerUI',
        ),
      ),
    ),
    'and' => array(
      'label' => t('Condition set (AND)'),
      'class' => 'RulesAnd',
      'embeddable' => 'RulesConditionContainer',
      'component' => TRUE,
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesConditionContainerUI',
        ),
      ),
    ),
    'action set' => array(
      'label' => t('Action set'),
      'class' => 'RulesActionSet',
      'embeddable' => FALSE,
      'component' => TRUE,
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesActionContainerUI',
        ),
      ),
    ),
    'rule' => array(
      'label' => t('Rule'),
      'class' => 'Rule',
      'embeddable' => 'RulesRuleSet',
      'component' => TRUE,
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesRuleUI',
        ),
      ),
    ),
    'loop' => array(
      'class' => 'RulesLoop',
      'embeddable' => 'RulesActionContainer',
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesLoopUI',
        ),
      ),
    ),
    'reaction rule' => array(
      'class' => 'RulesReactionRule',
      'embeddable' => FALSE,
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesReactionRuleUI',
        ),
      ),
    ),
    'event set' => array(
      'class' => 'RulesEventSet',
      'embeddable' => FALSE,
    ),
    'rule set' => array(
      'label' => t('Rule set'),
      'class' => 'RulesRuleSet',
      'component' => TRUE,
      // Rule sets don't get embedded - we use a separate action to execute.
      'embeddable' => FALSE,
      'extenders' => array(
        'RulesPluginUIInterface' => array(
          'class' => 'RulesRuleSetUI',
        ),
      ),
    ),
  );
}

/**
 * Implementation of hook_entity_info().
 */
function rules_entity_info() {
  return array(
    'rules_config' => array(
      'label' => t('Rules configuration'),
      'controller class' => 'RulesEntityController',
      'base table' => 'rules_config',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'id',
        'name' => 'name',
        'label' => 'label',
      ),
      'module' => 'rules',
      'static cache' => TRUE,
      'bundles' => array(),
      'configuration' => TRUE,
      'exportable' => TRUE,
      'export' => array(
        'default hook' => 'default_rules_configuration',
      ),
      'access callback' => 'rules_config_access',
      'features controller class' => 'RulesFeaturesController',
    ),
  );
}

/**
 * Implementation of hook_hook_info().
 */
function rules_hook_info() {
  foreach(array('plugin_info', 'data_info', 'condition_info', 'action_info', 'event_info', 'file_info', 'evaluator_info', 'data_processor_info') as $hook) {
    $hooks['rules_' . $hook] = array(
      'group' => 'rules',
    );
    $hooks['rules_' . $hook . '_alter'] = array(
      'group' => 'rules',
    );
  }
  $hooks['default_rules_configuration'] = array(
    'group' => 'rules_defaults',
  );
  $hooks['default_rules_configuration_alter'] = array(
    'group' => 'rules_defaults',
  );
  return $hooks;
}

/**
 * Load rule configurations from the database.
 *
 * This function should be used whenever you need to load more than one entity
 * from the database. The entities are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @see hook_entity_info()
 * @see RulesEntityController
 *
 * @param $names
 *   An array of rules configuration names or FALSE to load all.
 * @param $conditions
 *   An array of conditions in the form 'field' => $value.
 *
 * @return
 *   An array of rule configurations indexed by their ids.
 */
function rules_config_load_multiple($names = array(), $conditions = array()) {
  return entity_load_multiple_by_name('rules_config', $names, $conditions);
}

/**
 * Loads a single rule configuration from the database.
 *
 * @see rules_config_load_multiple()
 *
 * @return RulesPlugin
 */
function rules_config_load($name) {
  return entity_load_single('rules_config', $name);
}

/**
 * Returns an array of configured components.
 *
 * For actually executing a component use rules_invoke_component(), as this
 * retrieves the component from cache instead.
 *
 * @param $label
 *   Whether to return only the label or the whole component object.
 * @param $type
 *   Optionally filter for 'action' or 'condition' components.
 * @param $conditions
 *   An array of additional conditions as required by rules_config_load().
 *
 * @return
 *   An array keyed by component name containing either the label or the config.
 */
function rules_get_components($label = FALSE, $type = NULL, $conditions = array()) {
  $cache = rules_get_cache();
  $plugins = array_keys(rules_filter_array($cache['plugin_info'], 'component', TRUE));
  $conditions = $conditions + array('plugin' => $plugins);
  $faces = array(
    'action' => 'RulesActionInterface',
    'condition' => 'RulesConditionInterface',
  );
  $items = array();
  foreach (rules_config_load_multiple(FALSE, $conditions) as $name => $config) {
    if (!isset($type) || $config instanceof $faces[$type]) {
      $items[$name] = $label ? $config->label() : $config;
    }
  }
  return $items;
}

/**
 * Delete rule configurations from database.
 *
 * @param $ids
 *   An array of entity IDs.
 */
function rules_config_delete(array $ids) {
  return entity_get_controller('rules_config')->delete($ids);
}

/**
 * Ensures the configuration's 'dirty' flag is up to date by running an integrity check.
 *
 * @param $update
 *   (optional) Whether the dirty flag is also updated in the database if
 *   necessary. Defaults to TRUE.
 */
function rules_config_update_dirty_flag($rules_config, $update = TRUE) {
  // Keep a log of already check configurations to avoid repetitive checks on
  // oftent used components.
  // @see rules_element_invoke_component_validate()
  $checked = &drupal_static(__FUNCTION__, array());
  if (!empty($checked[$rules_config->name])) {
    return;
  }
  $checked[$rules_config->name] = TRUE;

  $was_dirty = !empty($rules_config->dirty);
  try {
    // First set the rule to dirty, so any repetitive checks give green light
    // for this configuration.
    $rules_config->dirty = FALSE;
    $rules_config->integrityCheck();
    if ($was_dirty) {
      $variables = array('%label' => $rules_config->label(), '%name' => $rules_config->name, '@plugin' => $rules_config->plugin());
      watchdog('rules', 'The @plugin %label (%name) was marked dirty, but passes the integrity check now and is active again.', $variables, WATCHDOG_INFO);
    }
  }
  catch (RulesIntegrityException $e) {
    $rules_config->dirty = TRUE;
    if (!$was_dirty) {
      $variables = array('%label' => $rules_config->label(), '%name' => $rules_config->name, '!message' => $e->getMessage(), '@plugin' => $rules_config->plugin());
      watchdog('rules', 'The @plugin %label (%name) fails the integrity check and cannot be executed. Error: !message', $variables, WATCHDOG_ERROR);
    }
  }
  // Save the updated dirty flag to the database.
  if ($was_dirty != $rules_config->dirty) {
    db_update('rules_config')
      ->fields(array('dirty' => (int) $rules_config->dirty))
      ->condition('id', $rules_config->id)
      ->execute();
  }
}

/**
 * Invokes a hook and the associated rules event.
 *
 * Calling this function does the same as calling module_invoke_all() and
 * rules_invoke_event() separately, however merges both functions into one in
 * order to ease usage and to work efficiently.
 *
 * @param $hook
 *   The name of the hook / event to invoke.
 * @param ...
 *   Arguments to pass to the hook / event.
 *
 * @return
 *   An array of return values of the hook implementations. If modules return
 *   arrays from their implementations, those are merged into one array.
 */
function rules_invoke_all() {
  // Copied code from module_invoke_all().
  $args = func_get_args();
  $hook = $args[0];
  unset($args[0]);
  $return = array();
  foreach (module_implements($hook) as $module) {
    $function = $module . '_' . $hook;
    if (function_exists($function)) {
      $result = call_user_func_array($function, $args);
      if (isset($result) && is_array($result)) {
        $return = array_merge_recursive($return, $result);
      }
      elseif (isset($result)) {
        $return[] = $result;
      }
    }
  }
  // Invoke the event.
  rules_invoke_event_by_args($hook, $args);

  return $return;
}

/**
 * Invokes configured rules for the given event.
 *
 * @param $event_name
 *   The event's name.
 * @param ...
 *   Pass parameters for the variables provided by this event, as defined in
 *   hook_rules_event_info(). Example given:
 *   @code
 *     rules_invoke_event('node_view', $node, $view_mode);
 *   @endcode
 *
 * @see rules_invoke_event_by_args()
 */
function rules_invoke_event() {
  global $conf;

  $args = func_get_args();
  $event_name = $args[0];
  unset($args[0]);
  // For invoking the rules event we directly acccess the global $conf. This is
  // fast without having to introduce another static cache.
  if (!defined('MAINTENANCE_MODE') && !isset($conf['rules_empty_sets'][$event_name]) && $event = rules_get_cache('event_' . $event_name)) {
    $event->executeByArgs($args);
  }
}

/**
 * Invokes configured rules for the given event.
 *
 * @param $event_name
 *   The event's name.
 * @param $args
 *   An array of parameters for the variables provided by the event, as defined
 *   in hook_rules_event_info(). Either pass an array keyed by the variable
 *   names or a numerically indexed array, in which case the ordering of the
 *   passed parameters has to match the order of the specified variables.
 *   Example given:
 *   @code
 *     rules_invoke_event_by_args('node_view', array('node' => $node, 'view_mode' => $view_mode));
 *   @endcode
 *
 * @see rules_invoke_event()
 */
function rules_invoke_event_by_args($event_name, $args = array()) {
  global $conf;

  // For invoking the rules event we directly acccess the global $conf. This is
  // fast without having to introduce another static cache.
  if (!defined('MAINTENANCE_MODE') && !isset($conf['rules_empty_sets'][$event_name]) && $event = rules_get_cache('event_' . $event_name)) {
    $event->executeByArgs($args);
  }
}

/**
 * Invokes a rule component, e.g. a rule set.
 *
 * @param $component_name
 *   The component's name.
 * @param $args
 *   Pass further parameters as required for the invoked component.
 *
 * @return
 *   An array of variables as provided by the component, or FALSE in case the
 *   component could not be executed.
 */
function rules_invoke_component() {
  $args = func_get_args();
  $name = array_shift($args);
  if ($component = rules_get_cache('comp_' . $name)) {
    return $component->executeByArgs($args);
  }
  return FALSE;
}

/**
 * Filters the given array of arrays by keeping only entries which have $key set
 * to the value of $value.
 *
 * @param $array
 *   The array of arrays to filter.
 * @param $key
 *   The key used for the comparison.
 * @param $value
 *   The value to compare the array's entry to.
 *
 * @return array
 *   The filtered array.
 */
function rules_filter_array($array, $key, $value) {
  $return = array();
  foreach ($array as $i => $entry) {
    $entry += array($key => NULL);
    if ($entry[$key] == $value) {
      $return[$i] = $entry;
    }
  }
  return $return;
}

/**
 * Merges the $update array into $array making sure no values of $array not
 * appearing in $update are lost.
 *
 * @return
 *   The updated array.
 */
function rules_update_array(array $array, array $update) {
  foreach ($update as $key => $data) {
    if (isset($array[$key]) && is_array($array[$key]) && is_array($data)) {
      $array[$key] = rules_update_array($array[$key], $data);
    }
    else {
      $array[$key] = $data;
    }
  }
  return $array;
}

/**
 * Extracts the property with the given name.
 *
 * @param $arrays
 *   An array of arrays from which a property is to be extracted.
 * @param $key
 *   The name of the property to extract.
 *
 * @return An array of extracted properties, keyed as in $arrays-
 */
function rules_extract_property($arrays, $key) {
  $data = array();
  foreach ($arrays as $name => $item) {
    $data[$name] = $item[$key];
  }
  return $data;
}

/**
 * Returns the first key of the array.
 */
function rules_array_key($array) {
  reset($array);
  return key($array);
}

/**
 * Clean replacements so they are URL friendly.
 *
 * Can be used as 'cleaning callback' for action or condition parameters.
 *
 * @param $replacements
 *   An array of token replacements that need to be "cleaned" for use in the URL.
 * @param $data
 *   An array of objects used to generate the replacements.
 * @param $options
 *   An array of options used to generate the replacements.
 *
 * @see rules_path_action_info()
 */
function rules_path_clean_replacement_values(&$replacements, $data = array(), $options = array()) {
  // Include path.eval.inc which contains path cleaning functions.
  module_load_include('inc', 'rules', 'modules/path.eval');
  foreach ($replacements as $token => $value) {
    $replacements[$token] = rules_clean_path($value);
  }
}

/**
 * Implements hook_theme().
 */
function rules_theme() {
  return array(
    'rules_elements' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_content_group' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_parameter_configuration' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_variable_view' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_data_selector_help' => array(
      'variables' => array('parameter' => NULL, 'variables' => NULL),
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_ui_variable_form' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_log' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_autocomplete' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_debug_element' => array(
      'render element' => 'element',
      'file' => 'ui/ui.theme.inc',
    ),
    'rules_settings_help' => array(
      'variables' => array('text' => '', 'heading' => ''),
      'file' => 'ui/ui.theme.inc',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function rules_permission() {
  $perms = array(
    'administer rules' => array(
      'title' => t('Administer rule configurations'),
      'description' => t('Administer rule configurations including events, conditions and actions for which the user has sufficient access permissions.'),
    ),
    'bypass rules access' => array(
      'title' => t('Bypass Rules access control'),
      'description' => t('Control all configurations regardless of permission restrictions of events, conditions or actions.'),
      'restrict access' => TRUE,
    ),
    'access rules debug' => array(
      'title' => t('Access the Rules debug log'),
    ),
  );

  // Fetch all components to generate the access keys.
  $conditions['plugin'] = array_keys(rules_filter_array(rules_fetch_data('plugin_info'), 'component', TRUE));
  $conditions['access_exposed'] = 1;
  $components = entity_load('rules_config', FALSE, $conditions);
  $perms += rules_permissions_by_component($components);

  return $perms;
}

/**
 * Helper function to get all the permissions for components that have access exposed.
 */
function rules_permissions_by_component(array $components = array()) {
  $perms = array();
  foreach ($components as $component) {
    $perms += array(
      "use Rules component $component->name" => array(
        'title' => t('Use Rules component %component', array('%component' => $component->label())),
        'description' => t('Controls access for using the component %component via the provided action or condition. <a href="@component-edit-url">Edit this component.</a>', array('%component' => $component->label(), '@component-edit-url' => url(RulesPluginUI::path($component->name)))),
      ),
    );
  }
  return $perms;
}

/**
 * Menu callback for loading rules configuration elements.
 * @see RulesUIController::config_menu()
 */
function rules_element_load($element_id, $config_name) {
  $config = rules_config_load($config_name);
  return $config->elementMap()->lookup($element_id);
}

/**
 * Menu callback for getting the title as configured.
 * @see RulesUIController::config_menu()
 */
function rules_get_title($text, $element) {
  if ($element instanceof RulesPlugin) {
    $cache = rules_get_cache();
    $plugin = $element->plugin();
    $plugin = isset($cache['plugin_info'][$plugin]['label']) ? $cache['plugin_info'][$plugin]['label'] : $plugin;
    $plugin = drupal_strtolower(drupal_substr($plugin, 0, 1)) . drupal_substr($plugin, 1);
    return t($text, array('!label' => $element->label(), '!plugin' => $plugin));
  }
  // As fallback treat $element as simple string.
  return t($text, array('!plugin' => $element));
}

/**
 * Menu callback for getting the title for the add element page.
 *
 * Uses a work-a-round for accessing the plugin name.
 * @see RulesUIController::config_menu()
 */
function rules_menu_add_element_title($array) {
  $plugin_name = arg($array[0]);
  $cache = rules_get_cache();
  if (isset($cache['plugin_info'][$plugin_name]['class'])) {
    $info = $cache['plugin_info'][$plugin_name] + array('label' => $plugin_name);
    $label = drupal_strtolower(drupal_substr($info['label'], 0, 1)) . drupal_substr($info['label'], 1);
    return t('Add a new !plugin', array('!plugin' => $label));
  }
}

/**
 * Returns the current region for the debug log.
 */
function rules_debug_log_region() {
  // If there is no setting for the current theme use the default theme setting.
  global $theme_key;
  $theme_default = variable_get('theme_default', 'bartik');
  return variable_get('rules_debug_region_' . $theme_key, variable_get('rules_debug_region_' . $theme_default, 'help'));
}

/**
 * Implements hook_page_build() to add the rules debug log to the page bottom.
 */
function rules_page_build(&$page) {
  // Invoke a the page redirect, in case the action has been executed.
  // @see rules_action_drupal_goto()
  if (isset($GLOBALS['_rules_action_drupal_goto_do'])) {
    list($url, $force) = $GLOBALS['_rules_action_drupal_goto_do'];
    drupal_goto($url);
  }

  if (isset($_SESSION['rules_debug'])) {
    $region = rules_debug_log_region();
    foreach ($_SESSION['rules_debug'] as $log) {
      $page[$region]['rules_debug'][] = array(
        '#markup' => $log,
      );
      $page[$region]['rules_debug']['#theme_wrappers'] = array('rules_log');
    }
    unset($_SESSION['rules_debug']);
  }

  if (rules_show_debug_output()) {
    $region = rules_debug_log_region();
    $page[$region]['rules_debug']['#pre_render'] = array('rules_debug_log_pre_render');
  }
}

/**
 * Pre-render callback for the debug log, which renders and then clears it.
 */
function rules_debug_log_pre_render($elements) {
  $logger = RulesLog::logger();
  if ($log = $logger->render()) {
    $logger = RulesLog::logger();
    $logger->clear();
    $elements[] = array('#markup' => $log);
    $elements['#theme_wrappers'] = array('rules_log');
    // Log the rules log to the system log if enabled.
    if (variable_get('rules_debug_log', FALSE)) {
      watchdog('rules', 'Rules debug information: !log', array('!log' => $log), WATCHDOG_NOTICE);
    }
  }
  return $elements;
}

/**
 * Implements hook_drupal_goto_alter().
 *
 * @see rules_action_drupal_goto()
 */
function rules_drupal_goto_alter(&$path, &$options, &$http_response_code) {
  // Invoke a the page redirect, in case the action has been executed.
  if (isset($GLOBALS['_rules_action_drupal_goto_do'])) {
    list($url, $force) = $GLOBALS['_rules_action_drupal_goto_do'];

    if ($force || !isset($_GET['destination'])) {
      $url = drupal_parse_url($url);
      $path = $url['path'];
      $options['query'] = $url['query'];
      $options['fragment'] = $url['fragment'];
      $http_response_code = 302;
    }
  }
}

/**
 * Returns whether the debug log should be shown.
 */
function rules_show_debug_output() {
  if (variable_get('rules_debug', FALSE) == RulesLog::INFO && user_access('access rules debug')) {
    return TRUE;
  }
  // For performance avoid unnecessary auto-loading of the RulesLog class.
  return variable_get('rules_debug', FALSE) == RulesLog::WARN && user_access('access rules debug') && class_exists('RulesLog', FALSE) && RulesLog::logger()->hasErrors();
}

/**
 * Implements hook_exit().
 */
function rules_exit() {
  if (rules_show_debug_output()) {
    if ($log = RulesLog::logger()->render()) {
      // Keep the log in the session so we can show it on the next page.
      $_SESSION['rules_debug'][] = $log;
    }
  }
  // Log the rules log to the system log if enabled.
  if (variable_get('rules_debug_log', FALSE) && $log = RulesLog::logger()->render()) {
    watchdog('rules', 'Rules debug information: !log', array('!log' => $log), WATCHDOG_NOTICE);
  }
}

/**
 * Implements hook_element_info().
 */
function rules_element_info() {
  // A duration form element for rules. Needs ui.forms.inc included.
  $types['rules_duration'] = array(
    '#input' => TRUE,
    '#tree' => TRUE,
    '#default_value' => 0,
    '#value_callback' => 'rules_ui_element_duration_value',
    '#process' => array('rules_ui_element_duration_process', 'ajax_process_form'),
    '#after_build' => array('rules_ui_element_duration_after_build'),
    '#pre_render' => array('form_pre_render_conditional_form_element'),
  );
  $types['rules_data_selection'] = array(
    '#input' => TRUE,
    '#pre_render' => array('form_pre_render_conditional_form_element'),
    '#process' => array('rules_data_selection_process', 'ajax_process_form'),
    '#theme' => 'rules_autocomplete',
  );
  return $types;
}

/**
 * Implements hook_modules_enabled().
 */
function rules_modules_enabled($modules) {
  // Re-enable Rules configurations that are dirty, because they require one of
  // the enabled the modules.
  $query = db_select('rules_dependencies', 'rd');
  $query->join('rules_config', 'rc', 'rd.id = rc.id');
  $query->fields('rd', array('id'))
        ->condition('rd.module', $modules, 'IN')
        ->condition('rc.dirty', 1);
  $ids = $query->execute()->fetchCol();

  // If there are some configurations that might work again, re-check all dirty
  // configurations as others might work again too, e.g. consider a rule that is
  // dirty because it requires a dirty component.
  if ($ids) {
    $rules_configs = rules_config_load_multiple(FALSE, array('dirty' => 1));
    foreach ($rules_configs as $rules_config) {
      try {
        $rules_config->integrityCheck();
        // If no exceptions were thrown we can set the configuration back to OK.
        db_update('rules_config')
          ->fields(array('dirty' => 0))
          ->condition('id', $rules_config->id)
          ->execute();
        if ($rules_config->active) {
          drupal_set_message(t('All dependencies for the Rules configuration %config are met again, so it has been re-activated.', array('%config' => $rules_config->label())));
        }
      }
      catch (RulesIntegrityException $e) {
        // The rule is still dirty, so do nothing.
      }
    }
  }
  rules_clear_cache();
}

/**
 * Implements hook_modules_disabled().
 */
function rules_modules_disabled($modules) {
  // Disable Rules configurations that depend on one of the disabled modules.
  $query = db_select('rules_dependencies', 'rd');
  $query->join('rules_config', 'rc', 'rd.id = rc.id');
  $query->fields('rd', array('id'))
        ->distinct()
        ->condition('rd.module', $modules, 'IN')
        ->condition('rc.dirty', 0);
  $ids = $query->execute()->fetchCol();

  if (!empty($ids)) {
    db_update('rules_config')
      ->fields(array('dirty' => 1))
      ->condition('id', $ids, 'IN')
      ->execute();
    // Tell the user about enabled rules that have been marked as dirty.
    $count = db_select('rules_config', 'r')
      ->fields('r')
      ->condition('id', $ids, 'IN')
      ->condition('active', 1)
      ->execute()->rowCount();
    if ($count > 0) {
      $message = format_plural($count,
        '1 Rules configuration requires some of the disabled modules to function and cannot be executed any more.',
        '@count Rules configuration require some of the disabled modules to function and cannot be executed any more.'
      );
      drupal_set_message($message, 'warning');
    }
  }
  rules_clear_cache();
}

/**
 * Access callback for dealing with Rules configurations.
 *
 * @see entity_access()
 */
function rules_config_access($op, $rules_config = NULL, $account = NULL) {
  if (user_access('bypass rules access', $account)) {
    return TRUE;
  }
  if (!isset($rules_config) || (isset($account) && $account->uid != $GLOBALS['user']->uid)) {
    return FALSE;
  }
  return user_access('administer rules', $account) && ($op == 'view' || $rules_config->access());
}

/**
 * Implements hook_menu().
 */
function rules_menu() {
  $items['admin/config/workflow/rules/upgrade'] = array(
    'title' => 'Upgrade',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rules_upgrade_form'),
    'access arguments' => array('administer rules'),
    'file' => 'includes/rules.upgrade.inc',
    'file path' => drupal_get_path('module', 'rules'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/workflow/rules/upgrade/clear'] = array(
    'title' => 'Clear',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('rules_upgrade_confirm_clear_form'),
    'access arguments' => array('administer rules'),
    'file' => 'includes/rules.upgrade.inc',
    'file path' => drupal_get_path('module', 'rules'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/workflow/rules/autocomplete_tags'] = array(
    'title' => 'Rules tags autocomplete',
    'page callback' => 'rules_autocomplete_tags',
    'page arguments' => array(5),
    'access arguments' => array('administer rules'),
    'file' => 'ui/ui.forms.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Helper function to keep track of external documentation pages for Rules.
 *
 * @param $topic
 *   The topic key for used for identifying help pages.
 *
 * @return
 *   Either a URL for the given page, or the full list of external help pages.
 */
function rules_external_help($topic = NULL) {
  $help = array(
    'rules' =>                'http://drupal.org/node/298480',
    'terminology' =>          'http://drupal.org/node/1299990',
    'condition-components' => 'http://drupal.org/node/1300034',
    'data-selection' =>       'http://drupal.org/node/1300042',
    'chained-tokens' =>       'http://drupal.org/node/1300042',
    'loops' =>                'http://drupal.org/node/1300058',
    'components' =>           'http://drupal.org/node/1300024',
    'component-types' =>      'http://drupal.org/node/1300024',
    'variables' =>            'http://drupal.org/node/1300024',
    'scheduler' =>            'http://drupal.org/node/1300068',
    'coding' =>               'http://drupal.org/node/878720',
  );

  if (isset($topic)) {
    return isset($help[$topic]) ? $help[$topic] : FALSE;
  }
  return $help;
}

/**
 * Implements hook_help().
 */
function rules_help($path, $arg) {
  // Only enable the help if the admin module is active.
  if ($path == 'admin/help#rules' && module_exists('rules_admin')) {

    $output['header'] = array(
      '#markup' => t('Rules documentation is kept online. Please use the links below for more information about Rules. Feel free to contribute to improving the online documentation!'),
    );
    // Build a list of essential Rules help pages, formatted as a bullet list.
    $link_list['rules'] = l(t('Rules introduction'), rules_external_help('rules'));
    $link_list['terminology'] = l(t('Rules terminology'), rules_external_help('terminology'));
    $link_list['scheduler'] = l(t('Rules Scheduler'), rules_external_help('scheduler'));
    $link_list['coding'] = l(t('Coding for Rules'), rules_external_help('coding'));

    $output['topic-list'] = array(
      '#markup' => theme('item_list', array('items' => $link_list)),
    );
    return render($output);
  }
}

/**
 * Implements hook_token_info().
 */
function rules_token_info() {
  $cache = rules_get_cache();
  $data_info = $cache['data_info'];

  $types = array('text', 'integer', 'uri', 'token', 'decimal', 'date', 'duration');

  foreach ($types as $type) {
    $token_type = $data_info[$type]['token type'];

    $token_info['types'][$token_type] = array(
      'name' => $data_info[$type]['label'],
      'description' => t('Tokens related to %label Rules variables.', array('%label' => $data_info[$type]['label'])),
      'needs-data' => $token_type,
    );
    $token_info['tokens'][$token_type]['value'] = array(
      'name' => t("Value"),
      'description' => t('The value of the variable.'),
    );
  }
  return $token_info;
}

/**
 * Implements hook_tokens().
 */
function rules_tokens($type, $tokens, $data, $options = array()) {
  // Handle replacements of primitive variable types.
  if (substr($type, 0, 6) == 'rules_' && !empty($data[$type])) {
    // Leverage entity tokens token processor by passing on as struct.
    $info['property info']['value'] = array(
      'type' => substr($type, 6),
      'label' => '',
    );
    // Entity tokens uses metadata wrappers as values for 'struct' types.
    $wrapper = entity_metadata_wrapper('struct', array('value' => $data[$type]), $info);
    return entity_token_tokens('struct', $tokens, array('struct' => $wrapper), $options);
  }
}
